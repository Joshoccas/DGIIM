<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica 1. Imágenes: Estudio de Eficiencia</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Práctica 1. Imágenes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Estudio de Eficiencia </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md0"></a>
Introducción</h2>
<p>Estudiaremos la eficiencia de dos posibles implementaciones del método <a class="el" href="classImage.html#a27d5bab7af11a729048b82af06f2d0c0" title="Baraja pseudoaleatoriamente las filas de una imagen.">Image::ShuffleRows()</a>. Consideraremos la eficiencia en el peor de los casos, utilizando como acotación la notación <a href="https://es.wikipedia.org/wiki/Notaci%C3%B3n_de_Landau">O-grande</a>. Este método, como ya se ha explicado, baraja las filas del objeto imagen sobre el que actúa.</p>
<p>Para la Implementación II se han modificado algunos métodos de la clase, de manera que en estos no se supone que img[i+1] == img[i]+cols, es decir, las filas no tienen por qué estar ordenadas consecutivamente en memoria. Dichos métodos son</p><ul>
<li><a class="el" href="classImage.html#aca8a815018d91548953cf571d778020e" title="Consulta el valor del píxel (fil, col) de la imagen.">Image::get_pixel</a> (int k)</li>
<li><a class="el" href="classImage.html#a6e316f867fd3b67a75d78ca66bc12195" title="Asigna el valor valor al píxel (fil, col) de la imagen.">Image::set_pixel</a> (int k, byte value)</li>
<li><a class="el" href="classImage.html#adde1007dc6359087dae65fa8cae26448" title="Almacena imágenes en disco.">Image::Save</a> (const char *file_path)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md2"></a>
Análisis teórico</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Implementación I</h3>
<blockquote class="doxtable">
<p><code>const int p = 9973;</code></p>
<p><code>int newr;</code></p>
<p><code><a class="el" href="classImage.html" title="T.D.A. Imagen.">Image</a> temp(rows,cols);</code></p>
<p><code>for (int r=0; r&lt;rows; r++){</code></p>
<blockquote class="doxtable">
<p><code>newr = r*prows;</code></p>
<p><code>for (int c=0; c&lt;cols;c++)</code></p>
<blockquote class="doxtable">
<p><code>temp.set_pixel(r,c,get_pixel(newr,c));</code> </p>
</blockquote>
</blockquote>
<p><code>}</code></p>
<p><code>Copy(temp);</code> </p>
</blockquote>
<p>Todas las instrucciones simples, a excepción de la llamada a Image::Copy(), son O(1). Vemos que hay dos bucles anidados; el bucle interno se ejecutará Image::cols veces y el principal Image::rows veces, luego el anidamiento es O(Image::rows * Image::cols).</p>
<blockquote class="doxtable">
<p><code>void Image::Copy(const Image &amp; orig){</code></p>
<blockquote class="doxtable">
<p><code>Initialize(orig.rows,orig.cols);</code></p>
<p><code>for (int k=0; k&lt;rows*cols;k++)</code></p>
<blockquote class="doxtable">
<p><code>set_pixel(k,orig.get_pixel(k));</code> </p>
</blockquote>
</blockquote>
<p><code>}</code> </p>
</blockquote>
<p>Este método es de orden O(Image::rows * Image::cols), luego la Implementación I es de orden <b>O(Image::rows * Image::cols)</b>.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Implemetación II</h3>
<blockquote class="doxtable">
<p><code>const int p = 9973;</code></p>
<p><code>byte **aux = new byte * [rows];</code></p>
<p><code>for (int r=0; r&lt;rows; r++)</code></p>
<blockquote class="doxtable">
<p><code>aux[r] = img[r];</code> </p>
</blockquote>
<p><code>for (int r=0; r&lt;rows; r++){</code></p>
<blockquote class="doxtable">
<p><code>int newr = r*prows;</code></p>
<p><code>img[r] = aux[newr];</code> </p>
</blockquote>
<p><code>}</code></p>
<p><code>delete [] aux;</code></p>
<p><code>aux = nullptr;</code> </p>
</blockquote>
<p>Al igual que en la implementación I, todas las instrucciones (sin contar los bucles) son O(1). En este caso no encontramos bucles anidados, y los dos bucles que aparecen realizan Image::rows iteraciones. Esta implementación es <b>O(Image::rows)</b>.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Conclusión.</h3>
<p>En el caso de las imágenes cuadradas (<em>rows=cols</em>), la eficiencia del método sería <b>O(n²) frente a O(n)</b> con <em>n=rows</em>. Para imágenes pequeñas (<em>n</em> pequeño) no supondría mucha diferencia pero a mayor número de filas y columnas mayor será la diferencia entre la eficiencia de las implementaciones. Luego la Implementación II supone una mejora considerable para la eficiencia general de la clase <a class="el" href="classImage.html" title="T.D.A. Imagen.">Image</a>.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md7"></a>
Análisis empírico</h2>
<p>Para poder ver la eficiencia de las dos versiones de <a class="el" href="classImage.html#a27d5bab7af11a729048b82af06f2d0c0" title="Baraja pseudoaleatoriamente las filas de una imagen.">Image::ShuffleRows</a>, hemos hecho uso de creareficiencia.cpp, fichero fuente con el que hemos medido los tiempos de ejecución de <a class="el" href="classImage.html#a27d5bab7af11a729048b82af06f2d0c0" title="Baraja pseudoaleatoriamente las filas de una imagen.">Image::ShuffleRows</a> para 100 casos distintos (imágenes de distintas dimensiones, yendo de menos a más tamaño).</p>
<p>En nuestro caso, hemos tomado matrices de 100 hasta 1000 filas y columnas, es decir, desde tamaño 10000 píxeles hasta 1000000 píxeles (los saltos de filas y columnas se han ido dando de 100 en 100, considerando todas las combinaciones posibles de filas x columnas). En cada una de las 100 pruebas se ha medido el tiempo de ejecución y dichos tiempos han sido recopilados en una hoja de cálculo de Google Drive, sacando a partir de ellos las <a href="https://docs.google.com/spreadsheets/d/1seGbphCXKLBInAMUcp3mJmi0btwPEqcl5QBhSaCz7Qk/edit#gid=0">gráficas</a> que se pedían</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Implementación I</h3>
<div class="image">
<img src="eficiencia1.png" alt=""/>
</div>
<p>Aunque para tamaños pequeños el tiempo de ejecución no es demasiado alto, este se dispara conforme las dimensiones de las imágenes van aumentado, como indican las gráficas. Un claro ejemplo es para una imagen 1000x1000, en la que el tiempo de espera son 858862 microsegundos, lo cual equivale a 0.86 segundos, una cantidad perceptible por el ser humano. Las imágenes cotidianas suelen ser de mayores dimensiones, lo cual significa que tardaría varios segundos en generar la imagen nueva. Esta implementación, por lo tanto, es insostenible para imágenes de gran tamaño.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Implementación II</h3>
<div class="image">
<img src="eficiencia2.png" alt=""/>
</div>
<p>En esta nueva implementación, viendo la línea de tendencia y su ecuación (tiempo frente a distinto nºfilas), vemos que los tiempos son mucho menores. Hemos prescindido de la gráfica en la que la variable independiente es el nºcolumnas porque la línea de tendencia indica que es constante, lo cual tiene sentido ya que en el código de la nueva implementación no interviene en ningún momento el nºcolumnas. Como en la gráfica para los distintos tamaños interviene el nºcolumnas también, pues tamaño = filas x columnas, hemos prescindido también de esta. En comparación con el ejemplo anterior, ahora para una imagen de 1000000 píxeles solo han hecho falta 525 microsegundos, lo que equivale a 0.000525, imperceptible por el ser humano.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Conclusión</h2>
<div class="image">
<img src="eficiencia3.png" alt=""/>
</div>
<p>Como prueba final de que la eficiencia de la nueva implementación es claramente mejor que la de la antigua, hemos unido las mismas 3 gráficas creadas para cada una de las implementaciones en 3 gráficas comparativas. Mientras que la antigua implementación hace que los tiempos se disparen para dimensiones altas, la nueva no lo hace (notemos que en todas las gráficas, las líneas de tendencia de la nueva implementación son horizontales con respecto a las de la antigua). Por lo tanto, el análisis teórico y empírico coinciden, como era de esperar. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
